$date
	Mon Apr 24 05:21:38 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module InvSubBytes_tb $end
$var wire 128 ! out [127:0] $end
$var reg 128 " in [127:0] $end
$scope module uut $end
$var wire 128 # InState [127:0] $end
$var wire 128 $ OutState [127:0] $end
$scope begin Sub_Bytes[0] $end
$var parameter 2 % i $end
$scope module uut $end
$var wire 8 & in [7:0] $end
$var reg 8 ' out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[8] $end
$var parameter 5 ( i $end
$scope module uut $end
$var wire 8 ) in [7:0] $end
$var reg 8 * out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[16] $end
$var parameter 6 + i $end
$scope module uut $end
$var wire 8 , in [7:0] $end
$var reg 8 - out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[24] $end
$var parameter 6 . i $end
$scope module uut $end
$var wire 8 / in [7:0] $end
$var reg 8 0 out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[32] $end
$var parameter 7 1 i $end
$scope module uut $end
$var wire 8 2 in [7:0] $end
$var reg 8 3 out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[40] $end
$var parameter 7 4 i $end
$scope module uut $end
$var wire 8 5 in [7:0] $end
$var reg 8 6 out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[48] $end
$var parameter 7 7 i $end
$scope module uut $end
$var wire 8 8 in [7:0] $end
$var reg 8 9 out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[56] $end
$var parameter 7 : i $end
$scope module uut $end
$var wire 8 ; in [7:0] $end
$var reg 8 < out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[64] $end
$var parameter 8 = i $end
$scope module uut $end
$var wire 8 > in [7:0] $end
$var reg 8 ? out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[72] $end
$var parameter 8 @ i $end
$scope module uut $end
$var wire 8 A in [7:0] $end
$var reg 8 B out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[80] $end
$var parameter 8 C i $end
$scope module uut $end
$var wire 8 D in [7:0] $end
$var reg 8 E out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[88] $end
$var parameter 8 F i $end
$scope module uut $end
$var wire 8 G in [7:0] $end
$var reg 8 H out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[96] $end
$var parameter 8 I i $end
$scope module uut $end
$var wire 8 J in [7:0] $end
$var reg 8 K out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[104] $end
$var parameter 8 L i $end
$scope module uut $end
$var wire 8 M in [7:0] $end
$var reg 8 N out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[112] $end
$var parameter 8 O i $end
$scope module uut $end
$var wire 8 P in [7:0] $end
$var reg 8 Q out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[120] $end
$var parameter 8 R i $end
$scope module uut $end
$var wire 8 S in [7:0] $end
$var reg 8 T out [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b1111000 R
b1110000 O
b1101000 L
b1100000 I
b1011000 F
b1010000 C
b1001000 @
b1000000 =
b111000 :
b110000 7
b101000 4
b100000 1
b11000 .
b10000 +
b1000 (
b0 %
$end
#0
$dumpvars
b11001 T
b11010100 S
b10100000 Q
b11100000 P
b10011010 N
b10111000 M
b11101001 K
b11110 J
b111101 H
b100111 G
b11110100 E
b10111111 D
b11000110 B
b10110100 A
b11111000 ?
b1000001 >
b11100011 <
b10001 ;
b11100010 9
b10011000 8
b10001101 6
b1011101 5
b1001000 3
b1010010 2
b10111110 0
b10101110 /
b101011 -
b11110001 ,
b101010 *
b11100101 )
b1000 '
b110000 &
b11001101000001001101011101001001111011111010011000110111110001110001111100010100011010100100010111110001010110010101000001000 $
b11010100111000001011100000011110001001111011111110110100010000010001000110011000010111010101001010101110111100011110010100110000 #
b11010100111000001011100000011110001001111011111110110100010000010001000110011000010111010101001010101110111100011110010100110000 "
b11001101000001001101011101001001111011111010011000110111110001110001111100010100011010100100010111110001010110010101000001000 !
$end
#10
b1001001 '
b1000011 *
b11110010 0
b1010000 3
b11101010 6
b110101 9
b1111111 <
b1101010 ?
b1011011 B
b10011111 E
b10011100 H
b10 K
b1101011 N
b1101000 Q
b10100100011010000110101100000010100111001001111101011011011010100111111100110101111010100101000011110010001010110100001101001001 !
b10100100011010000110101100000010100111001001111101011011011010100111111100110101111010100101000011110010001010110100001101001001 $
b10100100 T
b111011 &
b11010 )
b10001001 /
b1010011 2
b10000111 5
b10010110 8
b11010010 ;
b10 >
b111001 A
b11011011 D
b11011110 G
b1110111 J
b1111111 M
b1000101 P
b1001001 S
b1001001010001010111111101110111110111101101101100111001000000101101001010010110100001110101001110001001111100010001101000111011 "
b1001001010001010111111101110111110111101101101100111001000000101101001010010110100001110101001110001001111100010001101000111011 #
#20
