$date
	Tue May 16 02:45:44 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module SubBytes_tb $end
$var wire 128 ! out [127:0] $end
$var reg 128 " in [127:0] $end
$scope module uut $end
$var wire 128 # InState [127:0] $end
$var wire 128 $ OutState [127:0] $end
$scope begin Sub_Bytes[0] $end
$var parameter 2 % i $end
$scope module uut $end
$var wire 8 & in [7:0] $end
$var reg 8 ' out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[8] $end
$var parameter 5 ( i $end
$scope module uut $end
$var wire 8 ) in [7:0] $end
$var reg 8 * out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[16] $end
$var parameter 6 + i $end
$scope module uut $end
$var wire 8 , in [7:0] $end
$var reg 8 - out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[24] $end
$var parameter 6 . i $end
$scope module uut $end
$var wire 8 / in [7:0] $end
$var reg 8 0 out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[32] $end
$var parameter 7 1 i $end
$scope module uut $end
$var wire 8 2 in [7:0] $end
$var reg 8 3 out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[40] $end
$var parameter 7 4 i $end
$scope module uut $end
$var wire 8 5 in [7:0] $end
$var reg 8 6 out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[48] $end
$var parameter 7 7 i $end
$scope module uut $end
$var wire 8 8 in [7:0] $end
$var reg 8 9 out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[56] $end
$var parameter 7 : i $end
$scope module uut $end
$var wire 8 ; in [7:0] $end
$var reg 8 < out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[64] $end
$var parameter 8 = i $end
$scope module uut $end
$var wire 8 > in [7:0] $end
$var reg 8 ? out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[72] $end
$var parameter 8 @ i $end
$scope module uut $end
$var wire 8 A in [7:0] $end
$var reg 8 B out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[80] $end
$var parameter 8 C i $end
$scope module uut $end
$var wire 8 D in [7:0] $end
$var reg 8 E out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[88] $end
$var parameter 8 F i $end
$scope module uut $end
$var wire 8 G in [7:0] $end
$var reg 8 H out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[96] $end
$var parameter 8 I i $end
$scope module uut $end
$var wire 8 J in [7:0] $end
$var reg 8 K out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[104] $end
$var parameter 8 L i $end
$scope module uut $end
$var wire 8 M in [7:0] $end
$var reg 8 N out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[112] $end
$var parameter 8 O i $end
$scope module uut $end
$var wire 8 P in [7:0] $end
$var reg 8 Q out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[120] $end
$var parameter 8 R i $end
$scope module uut $end
$var wire 8 S in [7:0] $end
$var reg 8 T out [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b1111000 R
b1110000 O
b1101000 L
b1100000 I
b1011000 F
b1010000 C
b1001000 @
b1000000 =
b111000 :
b110000 7
b101000 4
b100000 1
b11000 .
b10000 +
b1000 (
b0 %
$end
#0
$dumpvars
b11010100 T
b11001 S
b100111 Q
b111101 P
b10001 N
b11100011 M
b10101110 K
b10111110 J
b11100000 H
b10100000 G
b10111111 E
b11110100 D
b10011000 B
b11100010 A
b11110001 ?
b101011 >
b10111000 <
b10011010 ;
b10110100 9
b11000110 8
b1011101 6
b10001101 5
b11100101 3
b101010 2
b11110 0
b11101001 /
b1000001 -
b11111000 ,
b1010010 *
b1001000 )
b110000 '
b1000 &
b11010100001001110001000110101110111000001011111110011000111100011011100010110100010111011110010100011110010000010101001000110000 $
b11001001111011110001110111110101000001111010011100010001010111001101011000110100011010010101011101001111110000100100000001000 #
b11001001111011110001110111110101000001111010011100010001010111001101011000110100011010010101011101001111110000100100000001000 "
b11010100001001110001000110101110111000001011111110011000111100011011100010110100010111011110010100011110010000010101001000110000 !
$end
#10
