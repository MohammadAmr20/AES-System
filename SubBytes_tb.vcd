$date
	Mon Apr 24 05:19:07 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module SubBytes_tb $end
$var wire 128 ! out [127:0] $end
$var reg 128 " in [127:0] $end
$scope module uut $end
$var wire 128 # InState [127:0] $end
$var wire 128 $ OutState [127:0] $end
$scope begin Sub_Bytes[0] $end
$var parameter 2 % i $end
$scope module uut $end
$var wire 8 & in [7:0] $end
$var reg 8 ' out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[8] $end
$var parameter 5 ( i $end
$scope module uut $end
$var wire 8 ) in [7:0] $end
$var reg 8 * out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[16] $end
$var parameter 6 + i $end
$scope module uut $end
$var wire 8 , in [7:0] $end
$var reg 8 - out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[24] $end
$var parameter 6 . i $end
$scope module uut $end
$var wire 8 / in [7:0] $end
$var reg 8 0 out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[32] $end
$var parameter 7 1 i $end
$scope module uut $end
$var wire 8 2 in [7:0] $end
$var reg 8 3 out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[40] $end
$var parameter 7 4 i $end
$scope module uut $end
$var wire 8 5 in [7:0] $end
$var reg 8 6 out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[48] $end
$var parameter 7 7 i $end
$scope module uut $end
$var wire 8 8 in [7:0] $end
$var reg 8 9 out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[56] $end
$var parameter 7 : i $end
$scope module uut $end
$var wire 8 ; in [7:0] $end
$var reg 8 < out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[64] $end
$var parameter 8 = i $end
$scope module uut $end
$var wire 8 > in [7:0] $end
$var reg 8 ? out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[72] $end
$var parameter 8 @ i $end
$scope module uut $end
$var wire 8 A in [7:0] $end
$var reg 8 B out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[80] $end
$var parameter 8 C i $end
$scope module uut $end
$var wire 8 D in [7:0] $end
$var reg 8 E out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[88] $end
$var parameter 8 F i $end
$scope module uut $end
$var wire 8 G in [7:0] $end
$var reg 8 H out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[96] $end
$var parameter 8 I i $end
$scope module uut $end
$var wire 8 J in [7:0] $end
$var reg 8 K out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[104] $end
$var parameter 8 L i $end
$scope module uut $end
$var wire 8 M in [7:0] $end
$var reg 8 N out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[112] $end
$var parameter 8 O i $end
$scope module uut $end
$var wire 8 P in [7:0] $end
$var reg 8 Q out [7:0] $end
$upscope $end
$upscope $end
$scope begin Sub_Bytes[120] $end
$var parameter 8 R i $end
$scope module uut $end
$var wire 8 S in [7:0] $end
$var reg 8 T out [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b1111000 R
b1110000 O
b1101000 L
b1100000 I
b1011000 F
b1010000 C
b1001000 @
b1000000 =
b111000 :
b110000 7
b101000 4
b100000 1
b11000 .
b10000 +
b1000 (
b0 %
$end
#0
$dumpvars
b11010100 T
b11001 S
b11100000 Q
b10100000 P
b10111000 N
b10011010 M
b11110 K
b11101001 J
b100111 H
b111101 G
b10111111 E
b11110100 D
b10110100 B
b11000110 A
b1000001 ?
b11111000 >
b10001 <
b11100011 ;
b10011000 9
b11100010 8
b1011101 6
b10001101 5
b1010010 3
b1001000 2
b10101110 0
b10111110 /
b11110001 -
b101011 ,
b11100101 *
b101010 )
b110000 '
b1000 &
b11010100111000001011100000011110001001111011111110110100010000010001000110011000010111010101001010101110111100011110010100110000 $
b11001101000001001101011101001001111011111010011000110111110001110001111100010100011010100100010111110001010110010101000001000 #
b11001101000001001101011101001001111011111010011000110111110001110001111100010100011010100100010111110001010110010101000001000 "
b11010100111000001011100000011110001001111011111110110100010000010001000110011000010111010101001010101110111100011110010100110000 !
$end
#10
b111011 '
b11010 *
b10001001 0
b1010011 3
b10000111 6
b10010110 9
b11010010 <
b10 ?
b111001 B
b11011011 E
b11011110 H
b1110111 K
b1111111 N
b1000101 Q
b1001001010001010111111101110111110111101101101100111001000000101101001010010110100001110101001110001001111100010001101000111011 !
b1001001010001010111111101110111110111101101101100111001000000101101001010010110100001110101001110001001111100010001101000111011 $
b1001001 T
b1001001 &
b1000011 )
b11110010 /
b1010000 2
b11101010 5
b110101 8
b1111111 ;
b1101010 >
b1011011 A
b10011111 D
b10011100 G
b10 J
b1101011 M
b1101000 P
b10100100 S
b10100100011010000110101100000010100111001001111101011011011010100111111100110101111010100101000011110010001010110100001101001001 "
b10100100011010000110101100000010100111001001111101011011011010100111111100110101111010100101000011110010001010110100001101001001 #
#20
